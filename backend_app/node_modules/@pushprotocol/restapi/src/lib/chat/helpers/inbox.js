"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decryptConversation = exports.getInboxLists = void 0;
const tslib_1 = require("tslib");
const constants_1 = require("../../constants");
const helpers_1 = require("../../helpers");
const user_1 = require("../../user");
const ipfs_1 = require("../ipfs");
const crypto_1 = require("./crypto");
const getInboxLists = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { lists, user, toDecrypt, pgpPrivateKey, env = constants_1.default.ENV.PROD, } = options || {};
    const connectedUser = yield (0, user_1.get)({ account: (0, helpers_1.pCAIP10ToWallet)(user), env });
    const feeds = [];
    for (const list of lists) {
        let message;
        if (list.threadhash !== null) {
            message = yield (0, ipfs_1.getCID)(list.threadhash, { env });
        }
        // This is for groups that are created without any message
        else {
            message = {
                encType: 'PlainText',
                encryptedSecret: '',
                fromCAIP10: '',
                fromDID: '',
                link: '',
                messageContent: '',
                messageType: '',
                sigType: '',
                signature: '',
                toCAIP10: '',
                toDID: ''
            };
        }
        feeds.push(Object.assign(Object.assign({}, list), { msg: message, groupInformation: list.groupInformation }));
    }
    if (toDecrypt)
        return (0, crypto_1.decryptFeeds)({ feeds, connectedUser, pgpPrivateKey, env });
    return feeds;
});
exports.getInboxLists = getInboxLists;
const decryptConversation = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { messages, connectedUser, pgpPrivateKey, env = constants_1.default.ENV.PROD, } = options || {};
    let otherPeer;
    let signatureValidationPubliKey; // To do signature verification it depends on who has sent the message
    let gotOtherPeer = false;
    for (const message of messages) {
        if (message.encType !== 'PlainText') {
            if (!pgpPrivateKey) {
                throw Error('Decrypted private key is necessary');
            }
            if (message.fromCAIP10 !== connectedUser.wallets.split(',')[0]) {
                if (!gotOtherPeer) {
                    otherPeer = yield (0, user_1.get)({ account: message.fromCAIP10, env });
                    gotOtherPeer = true;
                }
                signatureValidationPubliKey = otherPeer.publicKey;
            }
            else {
                signatureValidationPubliKey = connectedUser.publicKey;
            }
            message.messageContent = yield (0, helpers_1.decryptMessage)({
                encryptedMessage: message.messageContent,
                encryptedSecret: message.encryptedSecret,
                encryptionType: message.encType,
                signature: message.signature,
                signatureValidationPubliKey: signatureValidationPubliKey,
                pgpPrivateKey,
            });
        }
    }
    return messages;
});
exports.decryptConversation = decryptConversation;
//# sourceMappingURL=inbox.js.map