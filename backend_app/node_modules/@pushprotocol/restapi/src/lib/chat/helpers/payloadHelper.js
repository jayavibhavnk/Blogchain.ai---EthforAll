"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateGroupPayload = exports.createGroupPayload = exports.approveRequestPayload = exports.sendMessagePayload = void 0;
const tslib_1 = require("tslib");
const helpers_1 = require("../../helpers");
const crypto_1 = require("./crypto");
const getGroup_1 = require("../getGroup");
const sendMessagePayload = (receiverAddress, senderCreatedUser, messageContent, messageType, env) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    let isGroup = true;
    if (receiverAddress.includes('eip155:')) {
        isGroup = false;
    }
    let group = null;
    if (isGroup) {
        group = yield (0, getGroup_1.getGroup)({
            chatId: receiverAddress,
            account: '',
            env: env
        });
    }
    if (!group) {
        throw new Error(`Group not found!`);
    }
    const { message, encryptionType, aesEncryptedSecret, signature } = (yield (0, crypto_1.getEncryptedRequest)(receiverAddress, senderCreatedUser, messageContent, isGroup, env, group)) || {};
    const body = {
        fromDID: (0, helpers_1.walletToPCAIP10)(senderCreatedUser.wallets.split(',')[0]),
        toDID: isGroup ? receiverAddress : (0, helpers_1.walletToPCAIP10)(receiverAddress),
        fromCAIP10: (0, helpers_1.walletToPCAIP10)(senderCreatedUser.wallets.split(',')[0]),
        toCAIP10: isGroup ? receiverAddress : (0, helpers_1.walletToPCAIP10)(receiverAddress),
        messageContent: message,
        messageType,
        signature: signature,
        encType: encryptionType,
        encryptedSecret: aesEncryptedSecret,
        sigType: 'pgp',
    };
    return body;
});
exports.sendMessagePayload = sendMessagePayload;
const approveRequestPayload = (senderAddress, account, status) => {
    const signature = '1';
    let isGroup = true;
    if (senderAddress.includes('eip155:')) {
        isGroup = false;
    }
    const body = {
        fromDID: isGroup ? (0, helpers_1.walletToPCAIP10)(account) : (0, helpers_1.walletToPCAIP10)(senderAddress),
        toDID: isGroup ? senderAddress : (0, helpers_1.walletToPCAIP10)(account),
        signature,
        status,
        sigType: 'sigType',
    };
    return body;
};
exports.approveRequestPayload = approveRequestPayload;
const createGroupPayload = (groupName, groupDescription, members, groupImage, admins, isPublic, groupCreator, verificationProof, contractAddressNFT, numberOfNFTs, contractAddressERC20, numberOfERC20) => {
    const body = {
        groupName: groupName,
        groupDescription: groupDescription,
        members: members,
        groupImage: groupImage,
        admins: admins,
        isPublic: isPublic,
        contractAddressNFT: contractAddressNFT,
        numberOfNFTs: numberOfNFTs,
        contractAddressERC20: contractAddressERC20,
        numberOfERC20: numberOfERC20,
        groupCreator: groupCreator,
        verificationProof: verificationProof,
    };
    return body;
};
exports.createGroupPayload = createGroupPayload;
const updateGroupPayload = (groupName, profilePicture, members, admins, address, verificationProof) => {
    const body = {
        groupName: groupName,
        profilePicture: profilePicture,
        members: members,
        admins: admins,
        address: address,
        verificationProof: verificationProof
    };
    return body;
};
exports.updateGroupPayload = updateGroupPayload;
//# sourceMappingURL=payloadHelper.js.map